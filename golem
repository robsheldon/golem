#!/bin/bash
# This script should be located at /usr/local/sbin/golem

################################################################################
#                                                                              #
#    Globals                                                                   #
#                                                                              #
################################################################################

# restrict newly created files to read/write by this user only.
umask 077

# Batch (quiet) mode?
batch=0


################################################################################
#                                                                              #
#    Functions                                                                 #
#                                                                              #
################################################################################

##
# Return the path to the script file from either the cache or the script source
# directory whose name best matches the command the user wants to run.
# 
_find_cmd_file () {
    cmdstring="$1"
    shift
    for lookdir in "$@"; do
        # Ensure the directory exists.
        if [ ! -d "$scriptdir/$lookdir" ]; then
            continue
        fi
        # Iterate over the list of files in this directory from longest file
        # name to shortest.
        # The correct way to do this is to redirect the output from this nasty
        # series of commands as a redirect into `done`, e.g.:
        #     done < <(....)
        # But older verions of Bash vomit when you try that. Piping doesn't
        # work nicely on newer versions of Bash because it creates a subshell
        # which prevents later code from accessing any variables that are set,
        # exit doesn't work because the pipe is a subshell (it just exits the
        # pipe). So ... early return from a function!
        for scriptfile in "$scriptdir"/"$lookdir"/*.{sh,md,mdsh}; do echo ${#scriptfile} "$scriptfile"; done | sort -rn | cut -d " " -f 2 | while read -r filename; do
            if [ ! -f "$filename" ]; then
                # "Null globbing": patterns which don't match any files will
                # return the pattern. `shopt -s nullglob` also fixes this, but
                # testing for the file's existence is more portable.
                continue
            fi
            # Convert the filename into a regular expression...
            regex=$(path_basename "$filename" | sed 's/_/[[:space:]]\\{1,\\}.*[[:space:]]*/g')
            # ...and then try to match it against the entered command.
            if echo "$cmdstring" | grep -q "^$regex"; then
                echo "$filename"
                return 0
            fi
        done
    done
    echo ""
    return 1
}


##
# Update the command script cache.
#
_cache_update ()
{
    filename="$1"
    file_basename="$(path_basename "$filename")"
    # Delete any previous "-failed" scripts (files that did not successfully get imported).
    find -P "$scriptdir/scripts" -maxdepth 1 -name "$file_basename.*-failed" -delete
    sourcefiles=("$scriptdir"/scripts/"$file_basename".*)
    if [ ${#sourcefiles[@]} -gt 1 ]; then
        fail "There are multiple files in the $scriptdir/scripts matching the pattern $file_basename.*. There should be only one match for that pattern. Please rename some of them."
    elif [ ${#sourcefiles[@]} -lt 1 ] || [ "${sourcefiles[0]}" = "$scriptdir/scripts/$file_basename.*" ]; then
        fail "The original source file matching \"$file_basename\" has disappeared."
    fi
    sourcefile="${sourcefiles[0]}"
    # What happens next depends on the file extension for the source file.
    sourcetype=$(path_extension "$sourcefile")
    cachedfile=""
    warning="# Do not modify this file! This file is automatically generated from the source\\n# file at $sourcefile.\\n# Modify that file instead.\\n"
    sourcehash="$(md5sum "$sourcefile" | grep -oP '^[0-9a-f]{32}')"
    if [ ! -z "$sourcehash" ]; then
        warning="$warning# source hash: $sourcehash\\n"
    fi
    sudowarmup="# This script appears to require sudo, so make sure the user has the necessary access.\\n# If they do, then run a sudo command now so that script execution doesn't trip\\n# on a password prompt later.\\nif ! groups | grep -qw '\\(sudo\\|root\\)'; then\\n    fail \"It looks like this command script requires superuser access and you're not in the 'sudo' group\"\\nelif [ \"\$(sudo whoami </dev/null)\" != \"root\" ]; then\\n    fail \"Your 'sudo' command seems to be broken\"\\nfi\\n\\n"
    case "$sourcetype" in
        .sh)
            shellcheck=$(command -v shellcheck)
            if [ -n "$shellcheck" ]; then
                # Run shellcheck on the source file before using it, if available.
                if ! $shellcheck "$sourcefile" >/dev/null 2>&1; then
                    fail "The command script in $sourcefile isn't passing shellcheck. Please run \"shellcheck $sourcefile\", fix it, and then try again."
                fi
            fi
            # Shellcheck succeeded or is not available.
            cachedfile="$scriptdir/.cache/$file_basename.sh"
            # Nuke the 'sudo warmup' if it's not needed for this script.
            if ! grep -q '^[[:space:]]*\(if[[:space:]]*\)\?sudo ' "$sourcefile"; then
                sudowarmup=""
            fi
            # Inject the golem public code into this shell script.
            # See https://unix.stackexchange.com/a/193498 for an explanation of
            # this line noise.
            sed -n "/^# begin-golem-injected-code$/,/^# end-golem-injected-code$/p" "$scriptpath" | xargs -0 printf "\\n$warning\\n%s\\n$sudowarmup" | sed '/^\s*[^#]\+/{;r /dev/stdin
                N;:l;$!n;$!bl;};${;/^$/!{;s/\\n$//;};//d;}' "$sourcefile" <(printf \\n) >"$cachedfile"
            # Add a wrapper around apt installations to catch errors and force
            # bash to wait until the installation is concluded.
            # https://github.com/robsheldon/golem/issues/1
            sed -i -E -n 's/^(\s+)?(sudo\s*)?(apt(-get)?\s+)(install\s+)((-[a-zA-Z0-9-]+\s*)*)?(([a-zA-Z0-9:.+-]+\s*)+)$/\1echo "Installing: \8..."\n\1if \2\3\5\6\8 >\/dev\/null; then\n\1    echo "Successfully installed all packages"\n\1else\n\1    fail "Failed to install one or more of: \8"\n\1fi/;p' "$cachedfile"
            if [ -n "$shellcheck" ]; then
                # Run shellcheck one more time on the completed cached file.
                if ! $shellcheck "$cachedfile" >/dev/null 2>&1; then
                    fail "There was a conflict between \"$sourcefile\" and the golem code that gets added to command scripts. Please run \"shellcheck $cachedfile\" and then try again."
                fi
            fi
        ;;
        .md|.mdsh)
            # If md or mdsh is present, then markdown files ending in ".mdsh" can
            # be executed as commands if they pass all the sanity checks.
            mdsh=$(command -v mdsh)
            if [ -z "$mdsh" ]; then
                fail "mdsh is not installed or available in the current \$PATH. See https://github.com/bashup/mdsh for more information."
            fi
            shellcheck=$(command -v shellcheck)
            if [ -z "$shellcheck" ]; then
                fail "shellcheck is required for converting markdown documents to shell scripts. See https://github.com/koalaman/shellcheck for more information."
            fi
            # We really want to avoid getting a half-broken shell script in
            # the cache directory, so a temporary file is used here.
            tempfile=$(mktemp /tmp/golem.XXXXXX)
            # The next line constructs a special mdsh function to handle "bash"
            # language blocks; it natively only handles "shell" language blocks.
            # That function gets injected into the top of the input and then
            # passed to mdsh.
            if ! echo -e '```shell @mdsh\nmdsh-compile-bash(){ printf "%s" "$1";}\n```\n\n' | cat - "$sourcefile" | $mdsh --compile - >"$tempfile" 2>&1; then
                rm "$tempfile"
                fail "mdsh was unable to parse this file: \"$sourcefile\""
            fi
            # mdsh may parse the file as a raw block; make sure that didn't happen.
            if ! grep -q -v '^\s*\(mdsh_raw[a-zA-Z_:-]*+=.*\)\?$' "$tempfile"; then
                rm "$tempfile"
                fail "mdsh did not correctly parse this file: \"$sourcefile\". Make sure it has code blocks beginning with \"\`\`\`bash\" or \"\`\`\`shell\"."
            fi
            # So far, so good. Make sure the file has a "#!" near the top.
            # This is required for shellcheck to work properly.
            firstline=$(grep -v -m 1 '^\s*\(#[^!].*\)\?$' "$tempfile")
            if [[ ! "$firstline" =~ "^#!" ]]; then
                # Add an execution tag here.
                sed -i '1s:^:#!/bin/bash\n\n:' "$tempfile"
            fi
            # Copy the file out of /tmp now; it should be possible for the user
            # to review the compiled file if any errors are encountered after
            # this point.
            cat "$tempfile" > "$sourcefile-failed"
            rm "$tempfile"
            tempfile="$sourcefile-failed"
            # Shellcheck it. This is -required- for scripts imported through mdsh.
            if ! $shellcheck "$tempfile" >/dev/null 2>&1; then
                fail "The file converted by mdsh did not pass shellcheck. You can review the compiled file at \"$tempfile\"."
            fi
            # Nuke the 'sudo warmup' if it's not needed for this script.
            if ! grep -q '^[[:space:]]*\(if[[:space:]]*\)\?sudo ' "$tempfile"; then
                sudowarmup=""
            fi
            # Use the sed line noise to generate the file in the cache.
            cachedfile="$scriptdir/.cache/$file_basename.sh"
            sed -n "/^# begin-golem-injected-code$/,/^# end-golem-injected-code$/p" "$scriptpath" | xargs -0 printf "\\n$warning\\n%s\\n$sudowarmup" | sed '/^\s*[^#]\+/{;r /dev/stdin
                N;:l;$!n;$!bl;};${;/^$/!{;s/\\n$//;};//d;}' "$tempfile" <(printf \\n) >"$cachedfile"
            # Add a wrapper around apt installations to catch errors and force
            # bash to wait until the installation is concluded.
            # https://github.com/robsheldon/golem/issues/1
            sed -i -E -n 's/^(\s+)?(sudo\s*)?(apt(-get)?\s+)(install\s+)((-[a-zA-Z0-9-]+\s*)*)?(([a-zA-Z0-9:.+-]+\s*)+)$/\1echo "Installing: \8..."\n\1if \2\3\5\6\8 >\/dev\/null; then\n\1    echo "Successfully installed all packages"\n\1else\n\1    fail "Failed to install one or more of: \8"\n\1fi/;p' "$cachedfile"
            if ! $shellcheck "$cachedfile" >/dev/null 2>&1; then
                mv "$cachedfile" "$tempfile"
                cachedfile=""
                fail "\"$sourcefile\" was successfully converted to a shell script by mdsh but failed a shellcheck test when golem functions were added to it. You can review the compiled file at \"$tempfile\"."
            fi
            # The markdown script passed all tests. Nice!
            rm "$tempfile"
            ;;
        *)
            # All other file types: just copy the file into the cache and hope
            # the user knows what they're doing.
            filename=$(path_filename "$sourcefile")
            cachedfile="$scriptdir/.cache/$filename"
            cp "$sourcefile" "$cachedfile"
        ;;
    esac
    if [ -n "$cachedfile" ]; then
        chmod 0775 "$cachedfile"
        touch -r "$sourcefile" "$cachedfile"
    fi
    echo "$cachedfile"
    return 0
}


##
# Delete a command script from the cache, if it exists, and re-import it from
# a source. The source may be in the golem "scripts" directory, or may be an
# external script file that is to be added to the scripts directory and the
# command script cache.
_import_script () {
    invocation="$*"
    # Read parameters.
    sourcefile="$1"; shift
    destcmd=""
    if [ $# -gt 0 ] && [ "$1" = "as" ]; then
        shift
    fi
    if [ $# -gt 0 ]; then
        destcmd="$1"
        shift
    fi
    if [ $# -gt 0 ]; then
        fail "Wrong parameter count in _import_script. Invocation was: $invocation"
    fi
    if [ -z "$destcmd" ]; then
        # If no "as <command>" was provided, then this is an internal cache update.
        cached=$(_cache_update "$sourcefile")
        if [ -f "$cached" ]; then
            echo "Successfully imported $sourcefile"
        else
            fail "$cached"
        fi
    else
        # Ensure the sourcefile exists.
        if [ ! -f "$sourcefile" ]; then
            fail "file does not exist: $sourcefile"
        elif [ ! -r "$sourcefile" ]; then
            fail "file exists but is not readable: $sourcefile" 
        fi
        destfile=$(echo "$destcmd" | sed 's/ \+/_/g')
        dest_ext=$(path_extension "$sourcefile")
        # Don't remove or overwrite the file that's about to be imported if the user tries to do that. (!)
        if [ "$(realpath -m "$scriptdir/scripts/$destfile$dest_ext")" != "$(realpath -m "$sourcefile")" ]; then
            matched=$(find -P "$scriptdir/scripts" -maxdepth 1 -name "$destfile.*")
            if [ -n "$matched" ]; then
                matched=$(path_filename "$matched")
                if ! ask "\"$destcmd\" matches the file \"$matched\" in scripts/. Do you want to replace this file?"; then
                    echo "Canceled."
                    exit 1
                else
                    rm "$scriptdir/scripts/$matched"
                fi
            fi
            if ! cp "$sourcefile" "$scriptdir/scripts/$destfile$dest_ext"; then
                fail "Copy failed."
            fi
        fi
        cached=$(_cache_update "$destfile")
        if [ -f "$cached" ]; then
            echo "Successfully imported \"$destcmd\" as \"$destfile$dest_ext\""
        else
            fail "$cached"
        fi
    fi
}


##
# Verify the integrity of the script cache: ensures the source file still exists,
# there's only one matching source file for the cache entry, and the timestamps
# still match. If any of these aren't true, then the cache gets updated or an
# error message is displayed and the command fails.
#
_cache_check () {
    file_basename="$1"
    # Locate matching source and cache file(s).
    sourcefiles=("$scriptdir"/scripts/"$file_basename".*)
    cachedfiles=("$scriptdir"/.cache/"$file_basename".*)
    # See if a cache update can be skipped.
    # The current version of bash should return a single-element array containing
    # the input glob if no matches were found, but future versions may change
    # this behavior.
    if [ ${#cachedfiles[@]} -eq 1 ] && [ ${#sourcefiles[@]} -eq 1 ] && [ "${cachedfiles[0]}" != "$scriptdir/.cache/$file_basename.*" ] && [ "${sourcefiles[0]}" != "$scriptdir/scripts/$file_basename.*" ]; then
        # Try a hash comparison first.
        cached_hash="$(head -n 10 "${cachedfiles[0]}" | grep -oP '(?<=^# source hash: )[0-9a-f]{32}')"
        if [ -n "$cached_hash" ] && [ "$cached_hash" = "$(md5sum "${sourcefiles[0]}" | grep -oP '^[0-9a-f]{32}')" ]; then
            # Good enough. This allows for timestamp mismatches between cached
            # scripts and their source files so long as the content of the source
            # file hasn't changed.
            echo "${cachedfiles[0]}"
            return 0
        fi
        # Hash not stored in cached script, or hash mismatch. Compare timestamps.
        cached_ts=$(date -r "${cachedfiles[0]}" '+%s')
        source_ts=$(date -r "${sourcefiles[0]}" '+%s')
        if [ "$cached_ts" = "$source_ts" ]; then
            # All checks passed, no update needed.
            echo "${cachedfiles[0]}"
            return 0
        fi
    fi
    # One of the above tests failed, so the cache needs to be updated.
    _import_script "${sourcefiles[0]}"
    return $?
}


##
# Translate a given command string into a matching script to be run.
#
_shell_resolve_cmd () {
    i=5
    while [ $i -gt 0 ]; do
        i=$((i-1))
        matchfile=$(_find_cmd_file "$@")
        if [ -z "$matchfile" ]; then
            # Nothing found in either the scripts/ directory or the cache. The
            # caller will handle this with an error message.
            echo ""
            return 1
        fi
        matchcmd=$(path_basename "$matchfile")
        cachefile=$(_cache_check "$matchcmd") || exit 1
        if [ -z "$cachefile" ]; then
            # The cached file didn't survive inspection, so try finding another
            # matching command script.
            continue
        fi
        echo "$cachefile"
        [ -n "$cachefile" ]
        return $?
    done
    # This should never happen.
    fail "No matching script could be found for this command after 5 tries."
}


##
# The content between begin-golem-injected-code and end-golem-injected-code
# gets inserted into the top of cached shell scripts.
#
# If shellcheck is available, then the cached scripts get shellchecked before
# and after this code is inserted.
#

# begin-golem-injected-code

# Use any of these as necessary.
# shellcheck disable=SC2034
scriptpath=$(readlink -m "$BASH_SOURCE")
# shellcheck disable=SC2034
scriptname=$(basename "$scriptpath")
# shellcheck disable=SC2034
scriptdir=$(dirname "$scriptpath")
# shellcheck disable=SC2034
scriptshell=$(readlink /proc/$$/exe)

# Exit with an error if an undefined variable is referenced.
set -u

# If any command in a pipeline fails, that return code will be used as the
# return code for the whole pipeline.
set -o pipefail

# Halt with a non-zero exit status if a TERM signal is received by this PID.
# This is used by the fail() function along with $scriptpid.
trap "exit 1" TERM


##
# Return the filename component of a path; this is identical to calling
# "basename [path]"
#
path_filename () {
    local path=""
    path=$(realpath -s -m "$1")
    echo "${path##*/}"
}


##
# Return the parent directory of a path; this is identical to calling
# "dirname [path]", but it also cleans up extra slashes in the path.
#
path_directory () {
    local filename=""
    filename=$(path_filename "$1")
    realpath -s -m "${1%$filename}"
}


##
# Return the basename of the filename component of a path. For example, return
# "my_file" from "/path/to/my_file.txt".
#
path_basename () {
    local filename="" base="" ext=""
    filename=$(path_filename "$1")
    base="${filename%%.[^.]*}"
    ext="${filename:${#base} + 1}"
    if [ -z "$base" ] && [ -n "$ext" ]; then
        echo ".$ext"
    else
        echo "$base"
    fi
}


##
# Return the extension (suffix) of the filename component of a path. Example:
# return ".tar.gz" for "my_file.tar.gz", and "" for ".test".
#
path_extension () {
    local filename="" basename=""
    filename=$(path_filename "$1")
    basename=$(path_basename "$filename")
    echo "${filename##$basename}"
}


##
# Generate a pseudorandom string. Accepts an argument for the length of the
# string; if no string length is provided, then it defaults to generating a
# string between 12 and 25 characters long.
#
# Similar-looking characters are filtered out of the result string.
#
random_string () {
    local -i num_chars=0
    if [ $# -gt 0 ]; then
        num_chars=$1
    else
        num_chars=$((12 + RANDOM % 12))
    fi
    tr -dc _A-Z-a-z-0-9 < /dev/urandom | tr -d '/+oO0lLiI1\n\r' | head -c $num_chars
}


##
# Write a message to stderr and continue execution.
#
warn () {
    echo "Warning: $*" | fmt -w 80 >&2
}


##
# Write a message to stderr and exit immediately with a non-zero code.
#
fail () {
    echo "ERROR: $*" | fmt -w 80 >&2
    pkill -TERM -g $$ "$scriptname" || kill TERM $$ >/dev/null 2>&1
    exit 1
}


##
# Ask the user a question and process the response, with options for defaults
# and timeouts.
#
ask () {
    # Options:
    #     --timeout N:     time out if there's no input for N seconds.
    #     --default ANS:   use ANS as the default answer on timeout or
    #                      if an empty answer is provided.
    #     --required:      don't accept a blank answer. Use this parameter
    #                      to make ask() accept any string.
    #
    # ask() gives the answer in its exit status, e.g.,
    # if ask "Continue?"; then ...
    local ans="" default="" prompt=""
    local -i timeout=0 required=0

    while [ $# -gt 0 ] && [[ "$1" ]]; do
        case "$1" in
            -d|--default)
                shift
                default=$1
                if [[ ! "$default" ]]; then warn "Missing default value"; fi
                default=$(tr '[:upper:]' '[:lower:]' <<< "$default")
                if [[ "$default" = "yes" ]]; then
                    default="y"
                elif [[ "$default" = "no" ]]; then
                    default="n"
                elif [ "$default" != "y" ] && [ "$default" != "n" ]; then
                    warn "Illegal default answer: $default"
                fi
                shift
            ;;

            -t|--timeout)
                shift
                if [[ ! "$1" ]]; then
                    warn "Missing timeout value"
                elif [[ ! "$1" =~ ^[0-9][0-9]*$ ]]; then
                    warn "Illegal timeout value: $1"
                else
                    timeout=$1
                fi
                shift
            ;;

            -r|--required)
                shift
                required=1
            ;;

            -*)
                warn "Unrecognized option: $1"
            ;;

            *)
                break
            ;;
        esac
    done

    # Sanity checks
    if [[ $timeout -ne 0  &&  ! "$default" ]]; then
        warn "ask(): Non-zero timeout requires a default answer"
        exit 1
    fi
    if [ $required -ne 0 ]; then
        if [ -n "$default" ] || [ "$timeout" -gt 0 ]; then
            warn "ask(): 'required' is not compatible with 'default' or 'timeout' parameters."
            exit 1
        fi
    fi
    if [[ ! "$*" ]]; then
        warn "Missing question"
        exit 1
    fi

    prompt="$*"
    if [ "$default" = "y" ]; then
        prompt="$prompt [Y/n] "
    elif [ "$default" = "n" ]; then
        prompt="$prompt [y/N] "
    elif [ $required -eq 1 ]; then
        prompt="$prompt (required) "
    else
        prompt="$prompt [y/n] "
    fi


    while [ -z "$ans" ]
    do
        if [[ $timeout -ne 0 ]]; then
            if ! read -r -t "$timeout" -p "$prompt" ans </dev/tty; then
                ans=$default
                echo
            else
                # Turn off timeout if answer entered.
                timeout=0
                if [[ ! "$ans" ]]; then ans=$default; fi
            fi
        else
            read -r -p "$prompt" ans <"$(tty)"
            if [[ ! "$ans" ]]; then
                if [ $required -eq 1 ]; then
                    warn "An answer is required."
                    ans=""
                else
                    ans=$default
                fi
            elif [ $required -eq 0 ]; then
                ans=$(tr '[:upper:]' '[:lower:]' <<< $ans)
                if [ "$ans" = "yes" ]; then
                    ans="y"
                elif [ "$ans" = "no" ]; then
                    ans="n"
                fi
            fi 
        fi

        if [ $required -eq 0 ]; then
            if [ "$ans" != 'y' ] && [ "$ans" != 'n' ]; then
                warn "Invalid answer. Please use y or n."
                ans=""
            fi
        fi
    done

    if [ $required -eq 1 ]; then
        echo $ans
        return 0
    fi

    [[ "$ans" = "y" || "$ans" == "yes" ]]
}


##
# Return the value of a named option passed from the commandline.
# If it doesn't exist, exit with a non-zero status.
# This function can be invoked like so:
#     if var="$(loadopt "foo")"; then...
# 
loadopt () {
    local varname="$1" value=""
    declare -i found=1
    # Run through the longopts array and search for a "varname".
    for i in "${longopts[@]}"; do
        if [ $found -eq 0 ]; then
            value="$i"
            break
        fi
        if [ "$i" = "--$varname" ]; then
            # Matched varname, set found here so that the next loop iteration
            # picks up varname's value.
            found=0
        fi
    done
    echo "$value"
    return $found
}


##
# Require a named value from the user. If the value wasn't specified as a longopt
# when the script was invoked, then needopt() will call ask() to request the value
# from the user. Use this to get required values for your scripts.
#
needopt () {
    # Usage:
    #     varname=$(needopt varname -p "Prompt to the user" -m [regex])
    local varname="" prompt="" match="" i="" found="" value=""
    while [ $# -gt 0 ] && [[ "$1" ]]; do
        case "$1" in
            -p)
                shift
                if [ $# -gt 0 ]; then
                    prompt="$1"
                    shift
                fi
            ;;
            -m)
                shift
                if [ $# -gt 0 ]; then
                    match="$1"
                    shift
                fi
            ;;
            -*)
                warn "Unrecognized option: $1"
            ;;
            *)
                if [ -z "$varname" ]; then
                    varname="$1"
                    shift
                else
                    fail "needopt(): Unexpected value: $1"
                fi
            ;;
        esac
    done
    if [ -z "$varname" ]; then
        fail "needopt(): No varname was provided"
    fi
    if [ -z "$prompt" ]; then
        prompt="$varname"
    fi
    if ! value="$(loadopt "$varname")" || [[ ! $value =~ $match ]]; then
        while true; do
            value="$(ask -r "$prompt")"
            if [ -n "$value" ] && [[ $value =~ $match ]]; then
                break
            elif [ -n "$match" ]; then
                warn "needopt(): this value doesn't match the expected regular expression: $match"
            fi
        done
    fi
    # printf -v "$varname" '%s' "$value"
    echo "$value"
    return 0
}


# Process arguments. Golem will load any "--variable value" pairs into the
# "longopts" array. Your command script can then call the needopt() function to
# load this value into a variable.
# Example: if your command script needs a "hostname" value, the user can supply
# that with, "golem --hostname 'host.name' your command", and the "your_command.sh"
# file can use "hostname=needopt(hostname)" to create a variable named "hostname"
# with the value "host.name" (or ask the user for it).
declare -a longopts=()
declare -a args=()
while [ $# -gt 0 ] && [[ "$1" ]]; do
    case "$1" in
        --)
            # Stop processing arguments.
            break
            ;;
        --*)
            if [ $# -lt 2 ]; then
                fail "Missing value for $1"
            fi
            longopts+=("$(printf '%s' "$1")")
            longopts+=("$(printf '%s' "$2")")
            shift 2
            ;;
        *)
            args+=("$1")
            shift
            ;;
    esac
done
# Reset the arguments list to every argument that wasn't a --longopt.
set -- "${args[@]}"
unset args


################################################################################
#                                                                              #
#    Main program                                                              #
#                                                                              #
################################################################################

# end-golem-injected-code


# Extract any destinations from the arguments list.
declare -a destinations=()
declare -a args=()
while [ $# -gt 0 ] && [[ "$1" ]]; do
    case "$1" in
        @*)
            destinations+=("${1:1}")
            shift
            ;;
        *)
            args+=("$1")
            shift
            ;;
    esac
done
set -- "${args[@]}"
unset args

if [ $# -lt 1 ]; then
    # TODO: Needs a help subsystem.
    fail "No command provided"
fi

# Start a new blank line before any output if not in batch mode.
if [ "$1" = "-b" ] || [ "$1" = "-q" ]; then
    batch=1
    shift
else
    echo
fi

# Check the environment.
# A "scripts" directory should be present in the parent directory.
# This doesn't get automatically fixed because it's indicative of something
# unusual about the environment.
if [ ! -d "$scriptdir/scripts" ]; then
    fail "The \"scripts\" directory is missing from \"$scriptdir\". It should have been included in the repository. Please create it manually."
fi
# The .cache directory should exist because _import_script() uses it to sanity-
# check the environment. This can be created if it's not present.
if [ ! -d "$scriptdir/.cache" ]; then
    if ! mkdir -p "$scriptdir/.cache"; then
        fail "\"$scriptdir/.cache doesn't exist and could not be created. Please create it manually and try again."
    fi
fi

if [ $# -gt 2 ] && [ "$1" = "import" ] && [ "$2" = "script" ]; then
    # When invoked by the user, the "import script" words need to be shifted.
    shift; shift
    _import_script "$@"
else
    command_script=$(_shell_resolve_cmd "$*" ".cache" "scripts")
    if [ -z "$command_script" ]; then
        fail "No matching command script found for \"$*\""
    fi
    if [ ${#destinations[@]} -eq 0 ]; then
        # No remote destinations, run command script locally.
        $scriptshell "$command_script" "$(printf '%q ' "${longopts[@]}" "$@")"
    else
        # One or more remote destinations.
        # Start by converting the selected command script into a base64 blob.
        # This is because several different common approaches to executing
        # arbitrary shell scripts over ssh don't work well. After several hours
        # of trial and error, I found a better answer at this under-appreciated
        # comment on StackOverflow: https://unix.stackexchange.com/a/518960
        scripthack=$(base64 "$command_script" | tr -d '\n')
        for destination in "${destinations[@]}"; do
            # The destination should be defined in the user's local ssh config file.
            ssh_host=$(ssh -G "$destination" | grep -Pio '(?<=^hostname ).*$')
            if [ -z "$ssh_host" ]; then
                fail "your ssh configuration did not return a valid hostname for the remote destination $destination"
            fi
            hostaddr=$(ping -q -n -c 1 -t 1 -w 1 "$ssh_host" 2>&1 | head -n 1 | grep -Po "\\b$destination\\s+\\([^\\(\\)]+\\)")
            if [ -z "$hostaddr" ]; then
                # Try the hostname retrieved from the ssh config.
                hostaddr=$(ping -q -n -c 1 -t 1 -w 1 "$ssh_host" 2>&1 | head -n 1 | grep -Po "\\b$ssh_host\\s+\\([^\\(\\)]+\\)")
                if [ -z "$hostaddr" ]; then
                    fail "$destination could not be resolved to a valid network address"
                fi
            fi
            # Okay. Run this command script on a remote host.
            ssh -qt "$destination" /bin/bash "<(echo \"$scripthack\" | base64 --decode)" "$(printf '%q ' "${longopts[@]}" "$@")"
        done
    fi
fi

if [ $batch -eq 0 ]; then
    echo
fi
